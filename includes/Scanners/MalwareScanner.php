<?php
namespace SadranSecurity\Scanners;

use SadranSecurity\Logging\LogsDB;

if (! defined( 'ABSPATH' )) exit;

/**
 * MalwareScanner (HARDCORE mode)
 *
 * - Aggressive detection rules + entropy checks + filename heuristics
 * - Scheduled daily scan + on-demand run_scan()
 * - Logs all findings to LogsDB
 * - Quarantine disabled by default (enable via filter)
 *
 * Extensibility:
 * - filter 'sadran_malware_rules' to add/modify patterns (pattern => weight)
 * - filter 'sadran_malware_quarantine' to enable true/false
 * - filter 'sadran_malware_paths' to change scan folders
 * - filter 'sadran_malware_max_file_size' to change size limit
 * - filter 'sadran_malware_entropy_threshold' to change entropy cutoff
 */
class MalwareScanner {
    private static $instance = null;
    const CRON_HOOK = 'sadran_daily_malware_scan';

    private $rules = [];
    private $scan_paths = [];
    private $report = [];
    private $max_file_size = 2097152; // 2MB
    private $quarantine_dir;

    public static function instance() {
        if (null === self::$instance) self::$instance = new self();
        return self::$instance;
    }

    private function __construct() {
        $this->init_paths();
        $this->init_rules();
        $this->quarantine_dir = WP_CONTENT_DIR . '/uploads/sadran_quarantine';
    }

    public function maybe_schedule() {
        if (! wp_next_scheduled(self::CRON_HOOK)) {
            wp_schedule_event(time(), 'daily', self::CRON_HOOK);
        }
        add_action(self::CRON_HOOK, [$this, 'run_scan']);
    }

    private function init_paths() {
        $defaults = [
            ABSPATH . 'wp-includes',
            ABSPATH . 'wp-admin',
            WP_CONTENT_DIR . '/plugins',
            WP_CONTENT_DIR . '/themes',
            WP_CONTENT_DIR . '/uploads',
        ];
        $this->scan_paths = (array) apply_filters('sadran_malware_paths', $defaults);
        $this->max_file_size = max(1024, (int) apply_filters('sadran_malware_max_file_size', $this->max_file_size));
    }

    private function init_rules() {
        // pattern => weight (higher weight = more suspicious)
        $base = [
            '/base64_decode\s*\(/i'              => 8,
            '/eval\s*\(/i'                       => 8,
            '/gzinflate\s*\(/i'                  => 7,
            '/gzuncompress\s*\(/i'               => 7,
            '/str_rot13\s*\(/i'                  => 4,
            '/preg_replace\s*\(.*\/e[ismx]*\)/i' => 6, // legacy /e
            '/preg_replace\s*\(.*\\\$/i'         => 5,
            '/shell_exec\s*\(/i'                 => 8,
            '/passthru\s*\(/i'                   => 8,
            '/exec\s*\(/i'                       => 8,
            '/system\s*\(/i'                     => 7,
            '/pcntl_exec\s*\(/i'                 => 7,
            '/create_function\s*\(/i'            => 6,
            '/assert\s*\(/i'                     => 6,
            '/eval\\s*\\(\\s*\\$GLOBALS/i'       => 8,
            '/\\$GLOBALS\\[\\s*[\'"][a-zA-Z0-9_]{4,}?[\'"]\\s*\\]/i' => 3,
            '/(r57|c99|b374k|webshell|wsO)/i'     => 10,
            '/(base64_decode\(str_rot13|gzinflate\\(base64_decode)/i' => 10,
            '/(shell|backdoor|cmd|phpinfo)\\.(php|txt)/i' => 8,
            '/wp-content\\/uploads\\/.*\\.(php|phtml|php5)$/i' => 10,
            '/(chr\\(|pack\\(|unpack\\(|\\$\\w{30,})/i' => 5,
            '/\\$\\_[a-zA-Z]{1,3}\\s*\\[\\s*\\d+\\s*\\]/' => 3,
            '/(eval\\(|assert\\(|create_function\\(|preg_replace\\(|gzinflate\\(|base64_decode\\()/i' => 6,
            '/document\\.write\\(/i' => 2,
        ];

        // Merge and allow overrides
        $this->rules = (array) apply_filters('sadran_malware_rules', $base);
    }

    /**
     * Run a full scan. Returns report array.
     */
    public function run_scan() : array {
        $report = [
            'time' => time(),
            'scanned' => 0,
            'suspicious_files' => [],
            'stats' => [
                'suspicious' => 0,
                'scanned' => 0
            ]
        ];

        foreach ($this->scan_paths as $path) {
            if (!is_dir($path)) continue;
            try {
                $it = new \RecursiveIteratorIterator(
                    new \RecursiveDirectoryIterator($path, \FilesystemIterator::SKIP_DOTS),
                    \RecursiveIteratorIterator::LEAVES_ONLY
                );
            } catch (\UnexpectedValueException $e) {
                // permission denied on path
                continue;
            }

            foreach ($it as $f) {
                if (!$f->isFile()) continue;
                $report['stats']['scanned']++;

                $pathname = $f->getPathname();

                // skip obvious vendor, node, git caches
                $lower = strtolower($pathname);
                if (strpos($lower, '/node_modules/') !== false) continue;
                if (strpos($lower, '/.git/') !== false) continue;
                if (strpos($lower, '/vendor/') !== false) continue;

                // skip very large files
                if ($f->getSize() > $this->max_file_size) continue;

                // check file name heuristics
                $filename_score = $this->filename_heuristics($f->getFilename());

                // perform content scan
                $res = $this->scan_file($pathname);
                $res['filename_score'] = $filename_score;
                $res['total_score'] = $res['score'] + $filename_score;

                if ($res['total_score'] > 0) {
                    $report['suspicious_files'][$pathname] = $res;
                    $report['stats']['suspicious']++;

                    // Log suspicious file
                    LogsDB::instance()->log('malware', 'Suspicious file detected', 3, [
                        'file' => str_replace(ABSPATH, '', $pathname),
                        'score' => $res['total_score'],
                        'matches' => $res['matches'],
                    ]);

                    // Quarantine if enabled via filter (dangerous - manual review first)
                    $quarantine = (bool) apply_filters('sadran_malware_quarantine', false);
                    if ($quarantine) {
                        $this->quarantine_file($pathname);
                    }
                }
            }
        }

        // store short report
        update_option('sadran_malware_last_report', $report);
        // append to incidents
        $inc = (array) get_option('sadran_incidents', []);
        $inc[] = ['time'=>time(), 'type'=>'malware_scan', 'detail'=>$report['stats']];
        update_option('sadran_incidents', $inc);

        LogsDB::instance()->log('malware', 'Malware scan completed', 1, $report['stats']);

        $this->report = $report;
        return [
            'infected' => $infected_files,
            'scanned' => $scanned_files,
        ];
    }

    /**
     * Scan single file content and return matches + score
     */
    private function scan_file(string $pathname) : array {
        $content = @file_get_contents($pathname);
        if ($content === false) return ['score'=>0,'matches'=>[],'entropy'=>0];

        $score = 0;
        $matches = [];

        foreach ($this->rules as $pattern => $weight) {
            $count = @preg_match_all($pattern, $content, $m);
            if ($count > 0) {
                $score += ((int)$weight) * $count;
                $matches[$pattern] = $count;
            }
        }

        // long base64 blocks heuristic
        $base64_hits = $this->count_long_base64_blocks($content);
        if ($base64_hits > 0) {
            $score += 10 * $base64_hits;
            $matches['long_base64_blocks'] = $base64_hits;
        }

        // entropy check for long strings
        $entropy = $this->max_entropy_chunk($content);
        $entropy_threshold = floatval(apply_filters('sadran_malware_entropy_threshold', 4.2)); // approx suspicious
        if ($entropy > $entropy_threshold) {
            $score += intval(($entropy - $entropy_threshold) * 4);
            $matches['high_entropy'] = $entropy;
        }

        // filetype checks (PHP files prioritized)
        $ext = strtolower(pathinfo($pathname, PATHINFO_EXTENSION));
        if (in_array($ext, ['php','phtml','inc'])) {
            $score += 1;
        } else {
            // non-php with php content
            if (preg_match('/<\?php/i', $content)) {
                $score += 4;
                $matches['php_in_nonphp_file'] = 1;
            }
        }

        // small heuristics to reduce false positives
        if ($score > 0 && preg_match('/(^|\/)(readme|license|changelog|composer\\.json)$/i', $pathname) && $score < 6) {
            $score = max(0, $score - 4);
        }

        return ['score'=>$score, 'matches'=>$matches, 'entropy'=>$entropy];
    }

    /**
     * Filename heuristics: random names, odd extensions, long hex names
     */
    private function filename_heuristics(string $filename) : int {
        $low = strtolower($filename);
        $score = 0;

        // long random-looking filename e.g. 9c8f7a6b.php
        if (preg_match('/^[0-9a-f]{8,}\\.(php|phtml|php5)$/i', $filename)) $score += 6;

        // suspicious words
        if (preg_match('/(shell|backdoor|cmd|pwn|upload|dropper|tmp|cache)/i', $filename)) $score += 6;

        // double extension (e.g. pic.php.jpg)
        if (preg_match('/\\.(php|phtml|php5)\\.[a-z0-9]{2,4}$/i', $filename)) $score += 8;

        // tiny php file with single line often is a dropper
        if (preg_match('/\\.php$/i', $filename) && preg_match('/^[a-z0-9]{3,10}\\./i', $filename)) $score += 1;

        return $score;
    }

    /**
     * Count long base64 blocks in content (heuristic)
     */
    private function count_long_base64_blocks(string $text) : int {
        // find base64 segments >= 100 chars
        if (preg_match_all('/(?:[A-Za-z0-9+\/]{100,}={0,2})/', $text, $m)) {
            return count($m[0]);
        }
        return 0;
    }

    /**
     * Compute max entropy over chunks of content to detect obfuscation
     */
    private function max_entropy_chunk(string $content, $chunk = 512) : float {
        $len = strlen($content);
        if ($len === 0) return 0.0;
        $max = 0.0;
        for ($i = 0; $i < $len; $i += $chunk) {
            $part = substr($content, $i, $chunk);
            $e = $this->shannon_entropy($part);
            if ($e > $max) $max = $e;
        }
        return $max;
    }

    /**
     * Shannon entropy
     */
    private function shannon_entropy(string $s) : float {
        $m = [];
        $len = strlen($s);
        if ($len === 0) return 0.0;
        for ($i = 0; $i < $len; $i++) {
            $c = $s[$i];
            if (!isset($m[$c])) $m[$c] = 0;
            $m[$c]++;
        }
        $entropy = 0.0;
        foreach ($m as $count) {
            $p = $count / $len;
            $entropy -= $p * log($p, 2);
        }
        return $entropy;
    }

    /**
     * Quarantine a file (move to uploads/sadran_quarantine)
     */
    private function quarantine_file(string $pathname) {
        if (!is_dir($this->quarantine_dir)) {
            @wp_mkdir_p($this->quarantine_dir);
        }
        $dest = $this->quarantine_dir . '/' . md5($pathname . time()) . '_' . basename($pathname);
        @rename($pathname, $dest);
        LogsDB::instance()->log('malware', 'Quarantined file', 2, ['src'=>$pathname,'dest'=>$dest]);
    }

    /**
     * Return last report
     */
    public function last_report() : array {
        return (array) get_option('sadran_malware_last_report', $this->report);
    }
}
